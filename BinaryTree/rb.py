# -*- coding: utf-8 -*-
from __future__ import print_function

"""
平衡二叉查找树：二叉查找树中任意一个节点的左右子树的高度相差不能大于1。
    AVL树：是一种高度平衡的二叉查找树
解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。
平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

红黑树：一种不严格的平衡二叉查找树，是“近似平衡”的。
    （1）根节点是黑色的
    （2）每个叶子节点都是黑色的空节点（不存储数据），主要是为了简化红黑树的代码实现
    （3）任何相邻的节点都不能同时为红色
    （4）每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点
为什么说红黑树是“近似平衡”的：如果要证明红黑树是近似平衡的，我们只需要分析红黑树的高度是否比较稳定地趋近logn就好了。

*Treap（树堆）、*Splay Tree（伸展树）

1、把红黑树的平衡调整过程比作魔方复原，不要过于深究这个调整算法的正确性。只要按照固定步骤，保持插入、删除时不破坏平衡性就可以了。
2、找准关注节点，不要搞丢、搞错关注节点。在迭代的调整过程中，关注节点在不停地改变。
3、插入操作的平衡调整过程比较简单，但是删除操作的调整过程就比较复杂。针对删除操作，有两次调整，第一次是针对要删除的节点做初步调整，让其满足条件（4），第二次是为了满足条件（3）。

两个非常重要的操作：左旋（rotate left）、右旋（rotate right），即围绕某个节点的左旋、围绕某个节点的右旋。

插入操作的平衡调整：红黑树规定，插入的节点必须是红色。
如果插入节点的父节点是黑色的，则什么都不用做；
如果插入节点是根节点，则改变节点颜色为黑色即可；
除此之外，有以下3种情况需要调整：
    case1：如果关注节点是a，它的叔叔节点d是红色
    case2：如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点
    case3：如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的左子节点

删除操作的平衡调整：
针对删除节点的初步调整：
    case1：如果删除的节点是a，它只有一个子节点b
    case2：如果要删除的节点a有两个非空子节点，并且节点a的后继节点就是其右子节点c
    case3：如果要删除的节点a有两个非空子节点，并且节点a的后继节点不是其右子节点
针对关注节点的二次调整：
    case1：如果关注节点是a，它的兄弟节点c是红色
    case2：如果关注节点是a，它的兄弟节点c是黑色，并且节点c的左右子节点d、e都是黑色
    case3：如果关注节点是a，它的兄弟节点c是黑色，并且c的左子节点d是红色，c的右子节点e是黑色
    case4：如果关注节点是a，它的兄弟节点c是黑色，并且c的右子节点是红色

递归树：借助树来求解递归算法的时间复杂度。
分析快速排序的平均时间复杂度
分析斐波那契数列的时间复杂度
分析全排列的时间复杂度
"""
##全排列
def Permutations(arr,n,k):
    if k == 1:
        for i in range(n):
            print(arr[i],end=" ")
        print("")
    for i in range(k):
        tmp = arr[i]
        arr[i] = arr[k-1]
        arr[k-1] = tmp
        Permutations(arr,n,k-1)
        tmp = arr[i]
        arr[i] = arr[k-1]
        arr[k-1] = tmp


'''
全排列 回溯法
'''
def Pmt(prev,dep,arr,n):
    if dep == n:
        tmp = [str(v) for _,v in prev.items()]
        print(' '.join(tmp))
        return
    cur = [v for k,v in prev.items() if k < dep]
    diff = list(set(arr).difference(set(cur)))
    for i in diff:
        prev[dep] = i
        Pmt(prev,dep+1,arr,n)

if __name__ == "__main__":
    ##测试全排列
    arr = [1,2,3,4]
    Permutations(arr,len(arr),len(arr))
    print('huisu Permutations:')
    Pmt({},0,arr,len(arr))
